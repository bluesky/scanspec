


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>scanspec.core &mdash; scanspec 0.0+untagged.g6c97653 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/scanspec-logo.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: rgb(7, 43, 93)" >
          

          
            <a href="../../index.html" class="icon icon-home"> scanspec
          

          
            
            <img src="../../_static/scanspec-logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                master
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    <style>
      /* style mobile top nav to look like main nav */
      .wy-nav-top {
          background: rgb(7, 43, 93)
      }
    </style>
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/installation.html">Installation Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/creating-a-spec.html">Creating a Scan Spec</a></li>
</ul>
<p class="caption"><span class="caption-text">How-to Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../how-to/iterate-a-spec.html">How to Iterate a Spec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how-to/serialize-a-spec.html">How to Serialize and Deserialize a Spec</a></li>
</ul>
<p class="caption"><span class="caption-text">Explanations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/what-are-dimensions.html">What are Dimensions?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/why-squash-can-change-path.html">Why Squash (and Mask) can change the Path</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/contributing.html">Contributing</a></li>
</ul>

            
          
    <!-- Include Index in the sidebar -->
    <!-- https://stackoverflow.com/a/37843854 -->
    <a href="../../genindex.html">Index</a>
    <!-- Include all versions of the docs -->
    <!-- https://holzhaus.github.io/sphinx-multiversion/master/templates.html -->
    
    <p class="caption"><span class="caption-text">Versions</span></p>
    <ul>
      <li><a href="core.html">master</a></li>
      <li><a href="../../../0.2/index.html">0.2</a></li>
      <li><a href="../../../0.1.1/index.html">0.1.1</a></li>
      <li><a href="../../../0.1/index.html">0.1</a></li>
    </ul>
    
  
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">scanspec</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>scanspec.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scanspec.core</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">fields</span> <span class="k">as</span> <span class="n">dataclass_fields</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">new_class</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">ClassVar</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">apischema</span> <span class="kn">import</span> <span class="n">deserialize</span><span class="p">,</span> <span class="n">deserializer</span><span class="p">,</span> <span class="n">serialize</span>
<span class="kn">from</span> <span class="nn">apischema.conversions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Conversion</span><span class="p">,</span>
    <span class="n">LazyConversion</span><span class="p">,</span>
    <span class="n">dataclass_input_wrapper</span><span class="p">,</span>
    <span class="n">reset_deserializers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">apischema.metadata.implem</span> <span class="kn">import</span> <span class="n">ConversionMetadata</span>
<span class="kn">from</span> <span class="nn">apischema.metadata.keys</span> <span class="kn">import</span> <span class="n">CONVERSIONS_METADATA</span>
<span class="kn">from</span> <span class="nn">apischema.tagged_unions</span> <span class="kn">import</span> <span class="n">Tagged</span><span class="p">,</span> <span class="n">TaggedUnion</span><span class="p">,</span> <span class="n">get_tagged</span>

<span class="c1">#: The type of class the function will return</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>


<span class="c1"># Recursive implementation of type.__subclasses__</span>
<span class="k">def</span> <span class="nf">rec_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">]]:</span>
    <span class="k">for</span> <span class="n">sub_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">sub_cls</span>
        <span class="k">yield from</span> <span class="n">rec_subclasses</span><span class="p">(</span><span class="n">sub_cls</span><span class="p">)</span>


<span class="c1"># {cls_name: [functions]}</span>
<span class="n">_alternative_constructors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="alternative_constructor"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.alternative_constructor">[docs]</a><span class="k">def</span> <span class="nf">alternative_constructor</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Register an alternative constructor for this class. This will be returned</span>
<span class="sd">    as a staticmethod so the signature should not include self/cls.</span>

<span class="sd">    &gt;&gt;&gt; import dataclasses</span>
<span class="sd">    &gt;&gt;&gt; @dataclasses.dataclass</span>
<span class="sd">    ... class Foo:</span>
<span class="sd">    ...     a: int</span>
<span class="sd">    ...     @alternative_constructor</span>
<span class="sd">    ...     def doubled(b: int) -&gt; &quot;Foo&quot;:</span>
<span class="sd">    ...         return Foo(b * 2)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; Foo.doubled(2)</span>
<span class="sd">    Foo(a=4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cls_name</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">_alternative_constructors</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span></div>


<span class="k">def</span> <span class="nf">_update_serialization</span><span class="p">(</span><span class="n">parent_class</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Conversion</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Performs several tasks to setup (de)serialization. First,</span>
<span class="sd">    handle alternative constructors so they are added to the TaggedUnion.</span>
<span class="sd">    Second, calculate a tagged_union_conversion. Sub-classes are iterated</span>
<span class="sd">    over for a second time. This time each dataclass field is checked. If</span>
<span class="sd">    the dataclass field is of the same type as one of the serializable classes</span>
<span class="sd">    (i.e. a child of Serializable), its dynamic converion is updated.</span>
<span class="sd">    The tagged union is then used to register a a deserialization.</span>
<span class="sd">    It is also returned for use in dynamic conversions.&quot;&quot;&quot;</span>

    <span class="n">sub_cls</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">namespace</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">annotations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">Tagged</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">sub_cls</span> <span class="ow">in</span> <span class="n">rec_subclasses</span><span class="p">(</span><span class="n">parent_class</span><span class="p">):</span>
        <span class="c1"># Add tagged field for the Spec subclass</span>
        <span class="n">annotations</span><span class="p">[</span><span class="n">sub_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">sub_cls</span><span class="p">]</span>
        <span class="c1"># Add tagged fields for all its additional constructors</span>
        <span class="c1"># (use class __dict__ in order to avoid inheritances of this constructors)</span>
        <span class="k">for</span> <span class="n">constructor</span> <span class="ow">in</span> <span class="n">_alternative_constructors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sub_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="c1"># Build the alias of the field</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">capitalize</span><span class="p">,</span> <span class="n">constructor</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)))</span>
                <span class="o">+</span> <span class="n">sub_cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
            <span class="c1"># dataclass_input_wrapper uses get_type_hints, but the constructor</span>
            <span class="c1"># return type is stringified and the class not defined yet,</span>
            <span class="c1"># so it must be assigned manually</span>
            <span class="n">constructor</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">[</span><span class="s2">&quot;return&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_cls</span>
            <span class="c1"># Wraps the constructor and rename its input class</span>
            <span class="n">wrapper</span><span class="p">,</span> <span class="n">wrapper_cls</span> <span class="o">=</span> <span class="n">dataclass_input_wrapper</span><span class="p">(</span><span class="n">constructor</span><span class="p">)</span>
            <span class="n">wrapper_cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">alias</span>
            <span class="c1"># Add constructor tagged field with its conversion</span>
            <span class="n">annotations</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">sub_cls</span><span class="p">]</span>
            <span class="n">namespace</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">(</span><span class="n">deserialization</span><span class="o">=</span><span class="n">wrapper</span><span class="p">)</span>
    <span class="c1"># Create the tagged union class</span>
    <span class="n">namespace</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="vm">__annotations__</span><span class="o">=</span><span class="n">annotations</span><span class="p">,</span> <span class="o">**</span><span class="n">namespace</span><span class="p">)</span>

    <span class="n">tagged_union</span> <span class="o">=</span> <span class="n">new_class</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Tagged</span><span class="si">{</span><span class="n">parent_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">Union&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">TaggedUnion</span><span class="p">,),</span>
        <span class="n">exec_body</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">namespace</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">tagged_union_conversion</span> <span class="o">=</span> <span class="n">Conversion</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">tagged_union</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">obj</span><span class="p">}),</span>
        <span class="n">source</span><span class="o">=</span><span class="n">parent_class</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">tagged_union</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add dynamic conversions for attributes which are children of Serializable</span>
    <span class="k">for</span> <span class="n">sub_cls</span> <span class="ow">in</span> <span class="n">rec_subclasses</span><span class="p">(</span><span class="n">parent_class</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dataclass_fields</span><span class="p">(</span><span class="n">sub_cls</span><span class="p">):</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">metadata</span>
            <span class="k">if</span> <span class="n">meta</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">parent_class</span><span class="o">.</span><span class="n">registered_serializable</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">parent_class</span><span class="p">:</span>
                    <span class="n">conversion</span> <span class="o">=</span> <span class="n">tagged_union_conversion</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">conversion</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">conversion</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="o">**</span><span class="n">meta</span><span class="p">,</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="n">CONVERSIONS_METADATA</span><span class="p">:</span> <span class="n">ConversionMetadata</span><span class="p">(</span>
                            <span class="n">serialization</span><span class="o">=</span><span class="n">conversion</span>
                        <span class="p">)</span>
                    <span class="p">},</span>
                <span class="p">}</span>
                <span class="n">field</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">meta</span>

    <span class="c1"># Because deserializers stack, they must be reset before being reassigned</span>
    <span class="n">reset_deserializers</span><span class="p">(</span><span class="n">parent_class</span><span class="p">)</span>
    <span class="c1"># Register the deserializer using get_tagged</span>
    <span class="n">deserializer</span><span class="p">(</span>
        <span class="n">Conversion</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">get_tagged</span><span class="p">(</span><span class="n">obj</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">source</span><span class="o">=</span><span class="n">tagged_union</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">parent_class</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">tagged_union_conversion</span>


<div class="viewcode-block" id="Serializable"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Serializable">[docs]</a><span class="k">class</span> <span class="nc">Serializable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for registering apischema (de)serialization conversions.</span>
<span class="sd">    The conversion class variable of child classes holds the necessary information to</span>
<span class="sd">    (de)serialize grandchild classes. Each time a grandchild class is added</span>
<span class="sd">    conversion is updated to create a full TaggedUnion for the child class.&quot;&quot;&quot;</span>

    <span class="n">conversion</span> <span class="o">=</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Conversion</span><span class="p">]]</span>
    <span class="n">registered_serializable</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">parent_cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">parent_cls</span> <span class="o">==</span> <span class="n">Serializable</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">registered_serializable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">parent_cls</span><span class="o">.</span><span class="n">conversion</span> <span class="o">=</span> <span class="n">_update_serialization</span><span class="p">(</span><span class="n">parent_cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parent_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">serialize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">conversions</span><span class="o">=</span><span class="n">LazyConversion</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">parent_cls</span><span class="o">.</span><span class="n">conversion</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">serialization</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">deserialize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">serialization</span><span class="p">)</span></div>


<span class="c1">#: Map of positions keys to positions_ndarray</span>
<span class="c1">#: E.g. {xmotor: array([0, 1, 2]), ymotor: array([2, 2, 2])}</span>
<span class="n">Positions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>


<div class="viewcode-block" id="if_instance_do"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.if_instance_do">[docs]</a><span class="k">def</span> <span class="nf">if_instance_do</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">Any</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;If x is of type cls then return func(x), otherwise return NotImplemented.</span>
<span class="sd">    Used as a helper when implementing operator overloading&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="Dimension"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension">[docs]</a><span class="k">class</span> <span class="nc">Dimension</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents a linear stack of positions and bounds. A list of Dimensions</span>
<span class="sd">    is interpreted as nested from slowest moving to fastest moving, so each</span>
<span class="sd">    faster Dimension will iterate once per position of the slower Dimension.</span>
<span class="sd">    When fly-scanning they key will traverse lower-position-upper on the fastest</span>
<span class="sd">    Dimension for each point in the scan.</span>

<span class="sd">    Args:</span>
<span class="sd">        positions: The centre positions of the scan for each key</span>
<span class="sd">        lower: Lower bounds if different from positions</span>
<span class="sd">        upper: Upper bounds if different from positions</span>
<span class="sd">        snake: If True then every other iteration of this Dimension within a</span>
<span class="sd">            slower moving Dimension will be reversed</span>

<span class="sd">    See Also:</span>
<span class="sd">        `what-are-dimensions`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">positions</span><span class="p">:</span> <span class="n">Positions</span><span class="p">,</span>
        <span class="n">lower</span><span class="p">:</span> <span class="n">Positions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper</span><span class="p">:</span> <span class="n">Positions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snake</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">#: The centre positions of the scan for each key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span>
        <span class="c1">#: The lower bounds of each scan point for each key for fly-scanning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span> <span class="ow">or</span> <span class="n">positions</span>
        <span class="c1">#: The upper bounds of each scan point for each key for fly-scanning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span> <span class="ow">or</span> <span class="n">positions</span>
        <span class="c1">#: Whether every other iteration of this Dimension within a slower</span>
        <span class="c1">#: moving Dimension will be reversed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snake</span> <span class="o">=</span> <span class="n">snake</span>
        <span class="c1"># Check all keys and ordering are the same</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Mismatching keys &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Check all lengths are the same</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Mismatching lengths </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="Dimension.keys"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The keys that are present in `positions`, `lower` and `upper`</span>
<span class="sd">        which will move during the scan&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of `positions` in the scan&quot;&quot;&quot;</span>
        <span class="c1"># All positions arrays are same length, pick the first one</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_dim_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">apply_func</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)}</span>

        <span class="c1"># Apply to every array in positions</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="n">apply_func</span><span class="p">(</span><span class="s2">&quot;positions&quot;</span><span class="p">),</span> <span class="n">snake</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="p">)</span>
        <span class="c1"># If lower and upper are different, apply to those too</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">apply_func</span><span class="p">(</span><span class="s2">&quot;lower&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;upper&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">apply_func</span><span class="p">(</span><span class="s2">&quot;upper&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Dimension</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Dimension.tile"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension that iterates self reps times</span>

<span class="sd">        &gt;&gt;&gt; dim = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dim.tile(reps=2).positions</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3, 1, 2, 3])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_with</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="n">k</span><span class="p">],</span> <span class="n">reps</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dimension.repeat"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension that repeats each point in self reps times</span>

<span class="sd">        &gt;&gt;&gt; dim = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dim.repeat(reps=2).positions</span>
<span class="sd">        {&#39;x&#39;: array([1, 1, 2, 2, 3, 3])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_with</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="n">k</span><span class="p">],</span> <span class="n">reps</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dimension.mask"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension that produces only points from self in the</span>
<span class="sd">        mask</span>

<span class="sd">        &gt;&gt;&gt; dim = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dim.mask(np.array([1, 0, 1])).positions</span>
<span class="sd">        {&#39;x&#39;: array([1, 3])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_with</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="n">k</span><span class="p">][</span><span class="n">indices</span><span class="p">])</span></div>

<div class="viewcode-block" id="Dimension.copy"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a shallow copy of the current Dimension (dicts copied,</span>
<span class="sd">        arrays within them are not)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_with</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="n">k</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_check_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expected Dimension, got </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">snake</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">snake</span><span class="p">,</span> <span class="s2">&quot;Snake settings don&#39;t match&quot;</span>

<div class="viewcode-block" id="Dimension.concat"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension with arrays from self and other concatenated</span>
<span class="sd">        together. Require both Dimensions to have the same keys and snake</span>
<span class="sd">        settings</span>

<span class="sd">        &gt;&gt;&gt; dim = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dim2 = Dimension({&quot;x&quot;: np.array([5, 6, 7])})</span>
<span class="sd">        &gt;&gt;&gt; dim.concat(dim2).positions</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3, 5, 6, 7])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dim</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;Keys </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_with</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="n">k</span><span class="p">],</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="n">k</span><span class="p">]))</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Dimension.zip"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.zip">[docs]</a>    <span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension with arrays from keys of self and other</span>
<span class="sd">        merged together. Require both Dimensions to not share keys, and</span>
<span class="sd">        to have the snake settings</span>

<span class="sd">        &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([5, 6, 7])})</span>
<span class="sd">        &gt;&gt;&gt; dimx.zip(dimy).positions</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3]), &#39;y&#39;: array([5, 6, 7])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dim</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">overlapping</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">overlapping</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Zipping would overwrite keys </span><span class="si">{</span><span class="n">overlapping</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># rely on the constructor to check lengths</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span>
            <span class="n">positions</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">positions</span><span class="p">},</span>
            <span class="n">lower</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">lower</span><span class="p">},</span>
            <span class="n">upper</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">upper</span><span class="p">},</span>
            <span class="n">snake</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dim</span></div></div>


<div class="viewcode-block" id="squash_dimensions"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.squash_dimensions">[docs]</a><span class="k">def</span> <span class="nf">squash_dimensions</span><span class="p">(</span>
    <span class="n">dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dimension</span><span class="p">],</span> <span class="n">check_path_changes</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dimension</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Squash a list of nested Dimensions into a single one.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimensions: The Dimensions to squash, from slowest to fastest moving</span>
<span class="sd">        check_path_changes: If True then check that nesting the output</span>
<span class="sd">            Dimension within other Dimensions will provide the same path</span>
<span class="sd">            as nesting the input Dimension within other Dimensions</span>

<span class="sd">    See Also:</span>
<span class="sd">        `why-squash-can-change-path`</span>

<span class="sd">    &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2])}, snake=True)</span>
<span class="sd">    &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">    &gt;&gt;&gt; squash_dimensions([dimy, dimx]).positions</span>
<span class="sd">    {&#39;y&#39;: array([3, 3, 4, 4]), &#39;x&#39;: array([1, 2, 2, 1])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="c1"># Comsuming a Path of these dimensions performs the squash</span>
    <span class="c1"># TODO: dim.tile might give better performance but is much longer</span>
    <span class="n">squashed</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">consume</span><span class="p">()</span>
    <span class="c1"># Check that the squash is the same as the original</span>
    <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">snake</span><span class="p">:</span>
        <span class="n">squashed</span><span class="o">.</span><span class="n">snake</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># The top level is snaking, so this dimension will run backwards</span>
        <span class="c1"># This means any non-snaking axes will run backwards, which is</span>
        <span class="c1"># surprising, so don&#39;t allow it</span>
        <span class="k">if</span> <span class="n">check_path_changes</span><span class="p">:</span>
            <span class="n">non_snaking</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">snake</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">non_snaking</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot squash non-snaking Specs in a snaking Dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;otherwise </span><span class="si">{</span><span class="n">non_snaking</span><span class="si">}</span><span class="s2"> would run backwards&quot;</span>
                <span class="p">)</span>
    <span class="k">elif</span> <span class="n">check_path_changes</span><span class="p">:</span>
        <span class="c1"># The top level is not snaking, so make sure there is an even</span>
        <span class="c1"># number of iterations of any snaking axis within it so it</span>
        <span class="c1"># doesn&#39;t jump when this dimension is iterated a second time</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="c1"># A snaking dimension within a non-snaking top level must repeat</span>
            <span class="c1"># an even number of times</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">snake</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">_lengths</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot squash snaking Specs in a non-snaking Dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;when they do not repeat an even number of times &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;otherwise </span><span class="si">{</span><span class="n">dim</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> would jump in position&quot;</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">squashed</span></div>


<div class="viewcode-block" id="Path"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Path">[docs]</a><span class="k">class</span> <span class="nc">Path</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a consumable Path through a list of Dimensions representing a</span>
<span class="sd">    scan path.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimensions: The Dimensions describing the scan, from slowest to fastest</span>
<span class="sd">            moving</span>
<span class="sd">        start: The index of where in the Path to start</span>
<span class="sd">        num: The number of scan points to produce after start. None means up to</span>
<span class="sd">            the end</span>

<span class="sd">    See Also:</span>
<span class="sd">        `iterate-a-spec`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dimension</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">#: The Dimensions describing the scan, from slowest to fastest moving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>
        <span class="c1">#: Index that is next to be consumed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">])</span>
        <span class="c1">#: Index of the end point, one more than the last index that will be</span>
        <span class="c1">#: produced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span>

<div class="viewcode-block" id="Path.consume"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Path.consume">[docs]</a>    <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dimension</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Consume at most num points from the Path and return as a Dimension</span>

<span class="sd">        &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2])}, snake=True)</span>
<span class="sd">        &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">        &gt;&gt;&gt; path = Path([dimy, dimx])</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).positions</span>
<span class="sd">        {&#39;y&#39;: array([3, 3, 4]), &#39;x&#39;: array([1, 2, 2])}</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).positions</span>
<span class="sd">        {&#39;y&#39;: array([4]), &#39;x&#39;: array([1])}</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).positions</span>
<span class="sd">        {&#39;y&#39;: array([], dtype=int64), &#39;x&#39;: array([], dtype=int64)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">end_index</span>
        <span class="n">positions</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Example numbers below from a 2x3x4 ZxYxX scan</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="c1"># Number of times each position will repeat: Z:12, Y:4, X:1</span>
            <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="c1"># How big is this dim: Z:2, Y:3, X:4</span>
            <span class="n">dim_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Scan indices mapped to indices within dimension:</span>
            <span class="c1"># Z:000000000000111111111111</span>
            <span class="c1"># Y:000011112222000011112222</span>
            <span class="c1"># X:012301230123012301230123</span>
            <span class="n">dim_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">//</span> <span class="n">repeats</span><span class="p">)</span> <span class="o">%</span> <span class="n">dim_len</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">snake</span><span class="p">:</span>
                <span class="c1"># Whether this point is running backwards:</span>
                <span class="c1"># Z:000000000000000000000000</span>
                <span class="c1"># Y:000000000000111111111111</span>
                <span class="c1"># X:000011110000111100001111</span>
                <span class="n">backwards</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">//</span> <span class="p">(</span><span class="n">repeats</span> <span class="o">*</span> <span class="n">dim_len</span><span class="p">))</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="c1"># The scan indices mapped to snaking ones:</span>
                <span class="c1"># Z:000000000000111111111111</span>
                <span class="c1"># Y:000011112222222211110000</span>
                <span class="c1"># X:012332100123321001233210</span>
                <span class="n">snake_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">backwards</span><span class="p">,</span> <span class="n">dim_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dim_indices</span><span class="p">,</span> <span class="n">dim_indices</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">positions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">]</span>
                    <span class="c1"># If going backwards, select from the opposite bound</span>
                    <span class="n">lower</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">backwards</span><span class="p">,</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">upper</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">backwards</span><span class="p">,</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">positions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dim_indices</span><span class="p">]</span>
                    <span class="n">lower</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dim_indices</span><span class="p">]</span>
                    <span class="n">upper</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dim_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Dimension</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of points left in a scan, reduces when `consume` is called&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span></div>


<div class="viewcode-block" id="SpecPositions"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.SpecPositions">[docs]</a><span class="k">class</span> <span class="nc">SpecPositions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convenience iterable that produces the scan positions for each axis. For</span>
<span class="sd">    better performance, consume from a `Path` instead.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimensions: The Dimensions describing the scan, from slowest to fastest</span>
<span class="sd">            moving</span>

<span class="sd">    See Also:</span>
<span class="sd">        `iterate-a-spec`</span>

<span class="sd">    &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2])}, snake=True)</span>
<span class="sd">    &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">    &gt;&gt;&gt; sp = SpecPositions([dimy, dimx])</span>
<span class="sd">    &gt;&gt;&gt; for p in sp: print(p)</span>
<span class="sd">    {&#39;y&#39;: 3, &#39;x&#39;: 1}</span>
<span class="sd">    {&#39;y&#39;: 3, &#39;x&#39;: 2}</span>
<span class="sd">    {&#39;y&#39;: 4, &#39;x&#39;: 2}</span>
<span class="sd">    {&#39;y&#39;: 4, &#39;x&#39;: 1}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dimension</span><span class="p">]):</span>
        <span class="c1">#: The Dimensions describing the scan, from slowest to fastest moving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The keys that will be present in each position dictionary&quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">+=</span> <span class="n">dim</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">keys</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of dictionaries that will be produced if iterated over&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Positions</span><span class="p">]:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">dim</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Diamond Light Source.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>