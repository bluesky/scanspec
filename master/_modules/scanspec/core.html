

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>scanspec.core &mdash; scanspec 0.4+9.g91dbc3c documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/graphiql@1.0.3/graphiql.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/scanspec-logo.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/react@16.13.1/umd/react.production.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/react-dom@16.13.1/umd/react-dom.production.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/graphiql@1.0.3/graphiql.min.js"></script>
        <script src="../../_static/attachGraphiQL.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: rgb(7, 43, 93)" >
          

          
            <a href="../../index.html" class="icon icon-home"> scanspec
          

          
            
            <img src="../../_static/scanspec-logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                master
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
  <style>
    /* style mobile top nav to look like main nav */
    .wy-nav-top {
        background: rgb(7, 43, 93)
    }
  </style>
  
            
            
              
            
            
              <p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/installation.html">Installation Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/creating-a-spec.html">Creating a Scan Spec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/graphql-service.html">Running a GraphQL service for generating points</a></li>
</ul>
<p class="caption"><span class="caption-text">How-to Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../how-to/iterate-a-spec.html">How to Iterate a Spec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how-to/serialize-a-spec.html">How to Serialize and Deserialize a Spec</a></li>
</ul>
<p class="caption"><span class="caption-text">Explanations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/technical-terms.html">Technical Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/what-are-dimensions.html">What are Dimensions?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/why-squash-can-change-path.html">Why Squash (and Mask) can change the Path</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/contributing.html">Contributing</a></li>
</ul>

            
          
  <!-- Include Index in the sidebar -->
  <!-- https://stackoverflow.com/a/37843854 -->
  <a href="../../genindex.html">Index</a>
  <!-- Include link to changelog too -->
  <a href="https://github.com/dls-controls/scanspec/blob/master/CHANGELOG.rst">Changelog</a>
  <!-- Add versions for selected branches + tags -->
  <p class="caption"><span class="caption-text">Versions</span></p>
  <ul id="versions"/>
  <script>
    // Add any branches to appear in the side pane here, tags will be added below
    // Will only appear if docs are built and pushed in gh-pages
    var versions = ['master', 'main'];
    var dirs = new Set();
    function addVersion(name) {
      if (dirs.has(name)) {
        var li = document.createElement("li");
        var a = document.createElement("a");
        a.href = 'https://dls-controls.github.io/scanspec/' + name;
        a.innerText = name;
        li.appendChild(a)
        document.getElementById('versions').appendChild(li);
      }
    }
    Promise.all([
      // Find gh-pages directories and populate `dirs`
      fetch("https://api.github.com/repos/dls-controls/scanspec/contents?ref=gh-pages")
      .then(response => response.json())
      .then(data => data.forEach(function(e) {
        if (e.type == "dir") dirs.add(e.name);
      })),
      // Add tags to `versions`
      fetch('https://api.github.com/repos/dls-controls/scanspec/tags')
        .then(response => response.json())
        .then(data => data.forEach(function(e) {
          versions.push(e.name);
        }))
      ]).then(_ => versions.forEach(addVersion))
  </script>

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">scanspec</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>scanspec.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scanspec.core</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">new_class</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">ClassVar</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">apischema</span> <span class="kn">import</span> <span class="n">deserialize</span><span class="p">,</span> <span class="n">deserializer</span><span class="p">,</span> <span class="n">serialize</span><span class="p">,</span> <span class="n">serializer</span><span class="p">,</span> <span class="n">type_name</span>
<span class="kn">from</span> <span class="nn">apischema.conversions</span> <span class="kn">import</span> <span class="n">Conversion</span>
<span class="kn">from</span> <span class="nn">apischema.metadata</span> <span class="kn">import</span> <span class="n">conversion</span>
<span class="kn">from</span> <span class="nn">apischema.objects</span> <span class="kn">import</span> <span class="n">object_deserialization</span>
<span class="kn">from</span> <span class="nn">apischema.tagged_unions</span> <span class="kn">import</span> <span class="n">Tagged</span><span class="p">,</span> <span class="n">TaggedUnion</span><span class="p">,</span> <span class="n">get_tagged</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;S&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Serializable&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AxesPoints&quot;</span><span class="p">,</span>
    <span class="s2">&quot;if_instance_do&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Dimension&quot;</span><span class="p">,</span>
    <span class="s2">&quot;squash_dimensions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Path&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Midpoints&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">rec_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Recursive implementation of type.__subclasses__&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">sub_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">sub_cls</span>
        <span class="k">yield from</span> <span class="n">rec_subclasses</span><span class="p">(</span><span class="n">sub_cls</span><span class="p">)</span>


<span class="c1"># {cls_name: [functions]}</span>
<span class="n">_alternative_constructors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># Close enough for mypy</span>
    <span class="n">alternative_constructor</span> <span class="o">=</span> <span class="nb">staticmethod</span>
<span class="k">else</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">alternative_constructor</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register an alternative constructor for this class. This will be returned</span>
<span class="sd">        as a staticmethod so the signature should not include self/cls.</span>

<span class="sd">        &gt;&gt;&gt; import dataclasses</span>
<span class="sd">        &gt;&gt;&gt; @dataclasses.dataclass</span>
<span class="sd">        ... class Foo:</span>
<span class="sd">        ...     a: int</span>
<span class="sd">        ...     @alternative_constructor</span>
<span class="sd">        ...     def doubled(b: int) -&gt; &quot;Foo&quot;:</span>
<span class="sd">        ...         return Foo(b * 2)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Foo.doubled(2)</span>
<span class="sd">        Foo(a=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_name</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_alternative_constructors</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">as_tagged_union</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">serialization</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Conversion</span><span class="p">:</span>
        <span class="n">serialization_union</span> <span class="o">=</span> <span class="n">new_class</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Tagged</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">Union&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">TaggedUnion</span><span class="p">,),</span>
            <span class="n">exec_body</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;__annotations__&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">rec_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Conversion</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">serialization_union</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">obj</span><span class="p">}),</span>
            <span class="n">source</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">serialization_union</span><span class="p">,</span>
            <span class="c1"># Conversion must not be inherited because it would lead to infinite</span>
            <span class="c1"># recursion otherwise</span>
            <span class="n">inherited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialization</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Conversion</span><span class="p">:</span>
        <span class="n">annotations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">deserialization_namespace</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;__annotations__&quot;</span><span class="p">:</span> <span class="n">annotations</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">rec_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="n">annotations</span><span class="p">[</span><span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># Add tagged fields for all its alternative constructors</span>
            <span class="k">for</span> <span class="n">constructor</span> <span class="ow">in</span> <span class="n">_alternative_constructors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">()):</span>
                <span class="c1"># Build the alias of the field</span>
                <span class="n">alias</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">capitalize</span><span class="p">,</span> <span class="n">constructor</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)))</span>
                    <span class="o">+</span> <span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
                <span class="c1"># object_deserialization uses get_type_hints, but the constructor</span>
                <span class="c1"># return type is stringified and the class not defined yet,</span>
                <span class="c1"># so it must be assigned manually</span>
                <span class="n">constructor</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">[</span><span class="s2">&quot;return&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span>
                <span class="c1"># Add constructor tagged field with its conversion</span>
                <span class="n">annotations</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="n">deserialization_namespace</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">(</span>
                    <span class="n">conversion</span><span class="p">(</span>
                        <span class="c1"># Use object_deserialization to wrap constructor as deserializer</span>
                        <span class="n">deserialization</span><span class="o">=</span><span class="n">object_deserialization</span><span class="p">(</span>
                            <span class="n">constructor</span><span class="p">,</span> <span class="n">type_name</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="c1"># Create the deserialization tagged union class</span>
        <span class="n">deserialization_union</span> <span class="o">=</span> <span class="n">new_class</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Tagged</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">Union&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">TaggedUnion</span><span class="p">,),</span>
            <span class="n">exec_body</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">deserialization_namespace</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Conversion</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">get_tagged</span><span class="p">(</span><span class="n">obj</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">source</span><span class="o">=</span><span class="n">deserialization_union</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">cls</span>
        <span class="p">)</span>

    <span class="n">deserializer</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="n">deserialization</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">serializer</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="n">serialization</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>


<span class="c1">#: A subclass of Serializable</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Serializable&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Serializable"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Serializable">[docs]</a><span class="k">class</span> <span class="nc">Serializable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for registering apischema (de)serialization conversions.</span>
<span class="sd">    Each direct subclass will be registered for (de)serialization as a tagged union</span>
<span class="sd">    of its subclasses, using the pattern documented here:</span>
<span class="sd">    https://wyfo.github.io/apischema/examples/subclass_tagged_union/&quot;&quot;&quot;</span>

    <span class="c1"># Base class which will directly inherit from Serializable</span>
    <span class="n">_base_serializable</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="s2">&quot;Serializable&quot;</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Serializable</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_base_serializable</span> <span class="o">=</span> <span class="bp">cls</span>
            <span class="n">as_tagged_union</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

<div class="viewcode-block" id="Serializable.serialize"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Serializable.serialize">[docs]</a>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Serialize to a dictionary representation&quot;&quot;&quot;</span>
        <span class="c1"># Base serializable class must be passed to serialize in order to use its</span>
        <span class="c1"># registered conversion (which is not inherited)</span>
        <span class="k">return</span> <span class="n">serialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_serializable</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Serializable.deserialize"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Serializable.deserialize">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="n">serialization</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deserialize from a dictionary representation&quot;&quot;&quot;</span>
        <span class="n">inst</span> <span class="o">=</span> <span class="n">deserialize</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_base_serializable</span><span class="p">,</span> <span class="n">serialization</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inst</span></div></div>


<span class="c1">#: Map of axes to points_ndarray</span>
<span class="c1">#: E.g. {xmotor: array([0, 1, 2]), ymotor: array([2, 2, 2])}</span>
<span class="n">AxesPoints</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>


<div class="viewcode-block" id="if_instance_do"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.if_instance_do">[docs]</a><span class="k">def</span> <span class="nf">if_instance_do</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If x is of type cls then return func(x), otherwise return NotImplemented.</span>
<span class="sd">    Used as a helper when implementing operator overloading&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="Dimension"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension">[docs]</a><span class="k">class</span> <span class="nc">Dimension</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A dimension is a repeatable, possibly snaking structure of frames along a</span>
<span class="sd">    number of axes.</span>

<span class="sd">    Args:</span>
<span class="sd">        midpoints: The centre points of the scan for each axis</span>
<span class="sd">        lower: Lower bounds if different from midpoints</span>
<span class="sd">        upper: Upper bounds if different from midpoints</span>
<span class="sd">        gap: If supplied, define if there is a gap between frame and previous</span>
<span class="sd">            otherwise it is calculated by looking at lower and upper bounds</span>
<span class="sd">        snake: If True then every other iteration of this Dimension within a</span>
<span class="sd">            slower moving Dimension will be reversed</span>

<span class="sd">    Represents a linear stack of frames. A list of Dimensions</span>
<span class="sd">    is interpreted as nested from slowest moving to fastest moving, so each</span>
<span class="sd">    faster Dimension will iterate once per position of the slower Dimension.</span>
<span class="sd">    When fly-scanning the axis will traverse lower-midpoint-upper on the fastest</span>
<span class="sd">    Dimension for each point in the scan.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `what-are-dimensions`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_snake</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">midpoints</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">,</span>
        <span class="n">lower</span><span class="p">:</span> <span class="n">AxesPoints</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper</span><span class="p">:</span> <span class="n">AxesPoints</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">gap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snake</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">#: The centre points of the scan for each axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="o">=</span> <span class="n">midpoints</span>
        <span class="c1">#: The lower bounds of each scan point in each axis for fly-scanning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span> <span class="ow">or</span> <span class="n">midpoints</span>
        <span class="c1">#: The upper bounds of each scan point in each axis for fly-scanning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span> <span class="ow">or</span> <span class="n">midpoints</span>
        <span class="k">if</span> <span class="n">gap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#: Whether there is a gap between this frame and the previous. First</span>
            <span class="c1">#: element is whether there is a gap between the last frame and the first</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gap</span> <span class="o">=</span> <span class="n">gap</span>
            <span class="c1"># Don&#39;t use the setter to keep the pre-calculated gap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snake</span> <span class="o">=</span> <span class="n">snake</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Need to calculate gap as not passed one</span>
            <span class="c1"># We have a gap if upper[i] != lower[i+1] for any axes</span>
            <span class="n">axes_gap</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">l</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">axes_gap</span><span class="p">)</span>
            <span class="c1"># Use the setter to make sure self.gap is updated if snaking</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snake</span> <span class="o">=</span> <span class="n">snake</span>
        <span class="c1"># Check all axes and ordering are the same</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Mismatching axes &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Check all lengths are the same</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">lengths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Mismatching lengths </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">snake</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether every other iteration of this Dimension within a slower</span>
<span class="sd">        moving Dimension will be reversed&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snake</span>

    <span class="nd">@snake</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">snake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snake</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">snake</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snake</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">snake</span><span class="p">,</span> <span class="s2">&quot;Can only set snake=True after init&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snake</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># If we are snaking then there is never a gap between end and start</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Dimension.axes"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.axes">[docs]</a>    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The axes that are present in `midpoints`, `lower` and `upper`</span>
<span class="sd">        which will move during the scan&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of `frames` in the scan&quot;&quot;&quot;</span>
        <span class="c1"># All axespoints arrays are same length, pick the first one</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension that produces this dimension</span>
<span class="sd">        restricted to the slice</span>

<span class="sd">        &gt;&gt;&gt; dim = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dim[np.array([1, 0, 1])].midpoints</span>
<span class="sd">        {&#39;x&#39;: array([2, 1, 2])}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">apply_to_dict</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AxesPoints</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># If lower or upper are different, apply to those</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">:</span> <span class="n">apply_to_dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># Apply to midpoints, inherit snaked, force calculation of gap</span>
        <span class="k">return</span> <span class="n">Dimension</span><span class="p">(</span>
            <span class="n">midpoints</span><span class="o">=</span><span class="n">apply_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">),</span>
            <span class="n">gap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">snake</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_merge_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">,</span>
        <span class="n">dict_merge</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">AxesPoints</span><span class="p">,</span> <span class="n">AxesPoints</span><span class="p">],</span> <span class="n">AxesPoints</span><span class="p">],</span>
        <span class="n">gap_merge</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expected Dimension, got </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">snake</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">snake</span><span class="p">,</span> <span class="s2">&quot;Snake settings don&#39;t match&quot;</span>
        <span class="c1"># If lower or upper are different, apply to those</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">:</span> <span class="n">dict_merge</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">midpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># Apply to midpoints, inherit snaked, force calculation of gap</span>
        <span class="k">return</span> <span class="n">Dimension</span><span class="p">(</span>
            <span class="n">midpoints</span><span class="o">=</span><span class="n">dict_merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">midpoints</span><span class="p">),</span>
            <span class="n">gap</span><span class="o">=</span><span class="n">gap_merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">gap</span><span class="p">),</span>
            <span class="n">snake</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snake</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Dimension.concat"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">,</span> <span class="n">gap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension with arrays from self and other concatenated</span>
<span class="sd">        together. Require both Dimensions to have the same axes and snake</span>
<span class="sd">        settings</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The dimension to concatenate to self</span>
<span class="sd">            snake: Whether to force a gap between the two dimensions</span>

<span class="sd">        &gt;&gt;&gt; dim = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dim2 = Dimension({&quot;x&quot;: np.array([5, 6, 7])})</span>
<span class="sd">        &gt;&gt;&gt; dim.concat(dim2).midpoints</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3, 5, 6, 7])}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">concat_gap</span><span class="p">(</span><span class="n">gap1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">gap2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gap1</span><span class="p">,</span> <span class="n">gap2</span><span class="p">))</span>
            <span class="c1"># Calc the first point</span>
            <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_gap_between</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="c1"># And the join point</span>
            <span class="n">g</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">gap</span> <span class="ow">or</span> <span class="n">is_gap_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">g</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;axes </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_dims</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="c1"># Concat each array in midpoints, lower, upper. E.g.</span>
            <span class="c1"># lower[ax] = np.concatenate(self.lower[ax], other.lower[ax])</span>
            <span class="k">lambda</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d1</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="c1"># Gap should be concatted, but calc the join points above</span>
            <span class="n">concat_gap</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dim</span></div>

<div class="viewcode-block" id="Dimension.zip"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Dimension.zip">[docs]</a>    <span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Dimension&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Dimension with arrays from axes of self and other</span>
<span class="sd">        merged together. Require both Dimensions to not share axes, and</span>
<span class="sd">        to have the snake settings</span>

<span class="sd">        &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([5, 6, 7])})</span>
<span class="sd">        &gt;&gt;&gt; dimx.zip(dimy).midpoints</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3]), &#39;y&#39;: array([5, 6, 7])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlapping</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">()))</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">overlapping</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Zipping would overwrite axes </span><span class="si">{</span><span class="n">overlapping</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_dims</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="c1"># Merge dicts for midpoints, lower, upper. E.g.</span>
            <span class="c1"># lower[ax] = {**self.lower[ax], **other.lower[ax]}</span>
            <span class="k">lambda</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="p">{</span><span class="o">**</span><span class="n">d1</span><span class="p">,</span> <span class="o">**</span><span class="n">d2</span><span class="p">},</span>
            <span class="c1"># Gap if either dim has a gap. E.g.</span>
            <span class="c1"># gap[i] = self.gap[i] | other.gap[i]</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">is_gap_between</span><span class="p">(</span><span class="n">dim1</span><span class="p">:</span> <span class="n">Dimension</span><span class="p">,</span> <span class="n">dim2</span><span class="p">:</span> <span class="n">Dimension</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return if there is a gap between last point of upper and first point</span>
<span class="sd">    of lower&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">dim1</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim2</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dim1</span><span class="o">.</span><span class="n">axes</span><span class="p">())</span>


<div class="viewcode-block" id="squash_dimensions"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.squash_dimensions">[docs]</a><span class="k">def</span> <span class="nf">squash_dimensions</span><span class="p">(</span>
    <span class="n">dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dimension</span><span class="p">],</span> <span class="n">check_path_changes</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dimension</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Squash a list of nested Dimensions into a single one.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimensions: The Dimensions to squash, from slowest to fastest moving</span>
<span class="sd">        check_path_changes: If True then check that nesting the output</span>
<span class="sd">            Dimension within other Dimensions will provide the same path</span>
<span class="sd">            as nesting the input Dimension within other Dimensions</span>

<span class="sd">    See Also:</span>
<span class="sd">        `why-squash-can-change-path`</span>

<span class="sd">    &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2])}, snake=True)</span>
<span class="sd">    &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">    &gt;&gt;&gt; squash_dimensions([dimy, dimx]).midpoints</span>
<span class="sd">    {&#39;y&#39;: array([3, 3, 4, 4]), &#39;x&#39;: array([1, 2, 2, 1])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="c1"># Comsuming a Path of these dimensions performs the squash</span>
    <span class="c1"># TODO: dim.tile might give better performance but is much longer</span>
    <span class="n">squashed</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">consume</span><span class="p">()</span>
    <span class="c1"># Check that the squash is the same as the original</span>
    <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">and</span> <span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">snake</span><span class="p">:</span>
        <span class="n">squashed</span><span class="o">.</span><span class="n">snake</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># The top level is snaking, so this dimension will run backwards</span>
        <span class="c1"># This means any non-snaking axes will run backwards, which is</span>
        <span class="c1"># surprising, so don&#39;t allow it</span>
        <span class="k">if</span> <span class="n">check_path_changes</span><span class="p">:</span>
            <span class="n">non_snaking</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">snake</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">non_snaking</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot squash non-snaking Specs in a snaking Dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;otherwise </span><span class="si">{</span><span class="n">non_snaking</span><span class="si">}</span><span class="s2"> would run backwards&quot;</span>
                <span class="p">)</span>
    <span class="k">elif</span> <span class="n">check_path_changes</span><span class="p">:</span>
        <span class="c1"># The top level is not snaking, so make sure there is an even</span>
        <span class="c1"># number of iterations of any snaking axis within it so it</span>
        <span class="c1"># doesn&#39;t jump when this dimension is iterated a second time</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="c1"># A snaking dimension within a non-snaking top level must repeat</span>
            <span class="c1"># an even number of times</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">snake</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">_lengths</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot squash snaking Specs in a non-snaking Dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;when they do not repeat an even number of times &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;otherwise </span><span class="si">{</span><span class="n">dim</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="si">}</span><span class="s2"> would jump in position&quot;</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">squashed</span></div>


<div class="viewcode-block" id="Path"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Path">[docs]</a><span class="k">class</span> <span class="nc">Path</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A consumable route through one or more dimensions,</span>
<span class="sd">    representing a scan path.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimensions: The Dimensions describing the scan, from slowest to fastest</span>
<span class="sd">            moving</span>
<span class="sd">        start: The index of where in the Path to start</span>
<span class="sd">        num: The number of scan points to produce after start. None means up to</span>
<span class="sd">            the end</span>

<span class="sd">    See Also:</span>
<span class="sd">        `iterate-a-spec`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dimension</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">#: The Dimensions describing the scan, from slowest to fastest moving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>
        <span class="c1">#: Index that is next to be consumed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">])</span>
        <span class="c1">#: Index of the end point, one more than the last index that will be</span>
        <span class="c1">#: produced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span>

<div class="viewcode-block" id="Path.consume"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Path.consume">[docs]</a>    <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dimension</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Consume at most num points from the Path and return as a Dimension</span>

<span class="sd">        &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2])}, snake=True)</span>
<span class="sd">        &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">        &gt;&gt;&gt; path = Path([dimy, dimx])</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).midpoints</span>
<span class="sd">        {&#39;y&#39;: array([3, 3, 4]), &#39;x&#39;: array([1, 2, 2])}</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).midpoints</span>
<span class="sd">        {&#39;y&#39;: array([4]), &#39;x&#39;: array([1])}</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).midpoints</span>
<span class="sd">        {&#39;y&#39;: array([], dtype=int64), &#39;x&#39;: array([], dtype=int64)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">end_index</span>
        <span class="n">midpoints</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Example numbers below from a 2x3x4 ZxYxX scan</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="c1"># Number of times each point will repeat: Z:12, Y:4, X:1</span>
            <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="c1"># How big is this dim: Z:2, Y:3, X:4</span>
            <span class="n">dim_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Scan indices mapped to indices within dimension:</span>
            <span class="c1"># Z:000000000000111111111111</span>
            <span class="c1"># Y:000011112222000011112222</span>
            <span class="c1"># X:012301230123012301230123</span>
            <span class="n">dim_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">//</span> <span class="n">repeats</span><span class="p">)</span> <span class="o">%</span> <span class="n">dim_len</span>
            <span class="c1"># Whether this dim contributes to the gap bit</span>
            <span class="c1"># Z:000000000000100000000000</span>
            <span class="c1"># Y:000010001000100010001000</span>
            <span class="c1"># X:111111111111111111111111</span>
            <span class="n">in_gap</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">%</span> <span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">snake</span><span class="p">:</span>
                <span class="c1"># Whether this point is running backwards:</span>
                <span class="c1"># Z:000000000000000000000000</span>
                <span class="c1"># Y:000000000000111111111111</span>
                <span class="c1"># X:000011110000111100001111</span>
                <span class="n">backwards</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">//</span> <span class="p">(</span><span class="n">repeats</span> <span class="o">*</span> <span class="n">dim_len</span><span class="p">))</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="c1"># The scan indices mapped to snaking ones:</span>
                <span class="c1"># Z:000000000000111111111111</span>
                <span class="c1"># Y:000011112222222211110000</span>
                <span class="c1"># X:012332100123321001233210</span>
                <span class="n">snake_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">backwards</span><span class="p">,</span> <span class="n">dim_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dim_indices</span><span class="p">,</span> <span class="n">dim_indices</span>
                <span class="p">)</span>
                <span class="c1"># Gap is the difference between subsequent elements,</span>
                <span class="c1"># with True at the beginning, so the reverse dimension</span>
                <span class="c1"># needs to be one more than the snake_indices</span>
                <span class="c1"># Z:000000000000111111111111</span>
                <span class="c1"># Y:000011112222333322221111</span>
                <span class="c1"># X:012343210123432101233210</span>
                <span class="n">gap_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">backwards</span><span class="p">,</span> <span class="n">dim_len</span> <span class="o">-</span> <span class="n">dim_indices</span><span class="p">,</span> <span class="n">dim_indices</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">axes</span><span class="p">():</span>
                    <span class="n">midpoints</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">midpoints</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">]</span>
                    <span class="c1"># If going backwards, select from the opposite bound</span>
                    <span class="n">lower</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">backwards</span><span class="p">,</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">upper</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">backwards</span><span class="p">,</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                        <span class="n">dim</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gap_indices</span> <span class="o">=</span> <span class="n">dim_indices</span>
                <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">axes</span><span class="p">():</span>
                    <span class="n">midpoints</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">midpoints</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">dim_indices</span><span class="p">]</span>
                    <span class="n">lower</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">dim_indices</span><span class="p">]</span>
                    <span class="n">upper</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="n">dim_indices</span><span class="p">]</span>
            <span class="c1"># If in_gap, logical_or the relevant gap bit from the dim</span>
            <span class="c1"># We use % as gap_indices is 1..dim_len, with dim_len rolling</span>
            <span class="c1"># over to 0</span>
            <span class="n">gap</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">in_gap</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="n">gap_indices</span> <span class="o">%</span> <span class="n">dim_len</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Dimension</span><span class="p">(</span><span class="n">midpoints</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">gap</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of points left in a scan, reduces when `consume` is called&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span></div>


<div class="viewcode-block" id="Midpoints"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Midpoints">[docs]</a><span class="k">class</span> <span class="nc">Midpoints</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convenience iterable that produces the scan points for each axis. For</span>
<span class="sd">    better performance, consume from a `Path` instead.</span>

<span class="sd">    Args:</span>
<span class="sd">        dimensions: The Dimensions describing the scan, from slowest to fastest</span>
<span class="sd">            moving</span>

<span class="sd">    See Also:</span>
<span class="sd">        `iterate-a-spec`</span>

<span class="sd">    &gt;&gt;&gt; dimx = Dimension({&quot;x&quot;: np.array([1, 2])}, snake=True)</span>
<span class="sd">    &gt;&gt;&gt; dimy = Dimension({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">    &gt;&gt;&gt; mp = Midpoints([dimy, dimx])</span>
<span class="sd">    &gt;&gt;&gt; for p in mp: print(p)</span>
<span class="sd">    {&#39;y&#39;: 3, &#39;x&#39;: 1}</span>
<span class="sd">    {&#39;y&#39;: 3, &#39;x&#39;: 2}</span>
<span class="sd">    {&#39;y&#39;: 4, &#39;x&#39;: 2}</span>
<span class="sd">    {&#39;y&#39;: 4, &#39;x&#39;: 1}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dimension</span><span class="p">]):</span>
        <span class="c1">#: The Dimensions describing the scan, from slowest to fastest moving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The axes that will be present in each points dictionary&quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">+=</span> <span class="n">dim</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of dictionaries that will be produced if iterated over&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">AxesPoints</span><span class="p">]:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">dim</span><span class="o">.</span><span class="n">midpoints</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dim</span><span class="o">.</span><span class="n">axes</span><span class="p">()}</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Diamond Light Source.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>