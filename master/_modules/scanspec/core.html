<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scanspec.core &mdash; scanspec 0.5.3+2.g7de1778 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/graphiql@1.0.3/graphiql.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/scanspec-logo.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/react@16.13.1/umd/react.production.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/react-dom@16.13.1/umd/react-dom.production.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/graphiql@1.0.3/graphiql.min.js"></script>
        <script src="../../_static/attachGraphiQL.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: rgb(7, 43, 93)" >
            <a href="../../index.html" class="icon icon-home"> scanspec
            <img src="../../_static/scanspec-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                master
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/installation.html">Installation Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/creating-a-spec.html">Creating a Scan Spec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/graphql-service.html">Running a GraphQL service for generating points</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How-to Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../how-to/iterate-a-spec.html">How to Iterate a Spec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how-to/serialize-a-spec.html">How to Serialize and Deserialize a Spec</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Explanations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/technical-terms.html">Technical Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/why-stack-frames.html">Why create a stack of Frames?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../explanations/why-squash-can-change-path.html">Why Squash (and Mask) can change the Path</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/dls-controls/scanspec/blob/master/CHANGELOG.rst">Changelog</a></li>
<li class="toctree-l1"><a class="reference external" href="genindex.html#http://">Index</a></li>
</ul>

  <!-- Add versions for selected branches + tags -->
  <p class="caption">
    <span class="caption-text">Versions</span>
  </p>
  <ul id="versions"/>
  <script>
    // Add any branches to appear in the side pane here, tags will be added below
    // Will only appear if docs are built and pushed in gh-pages
    var versions = ['main', 'master'];
    var dirs = new Set();
    function addVersion(name) {
      if (dirs.has(name)) {
        var li = document.createElement("li");
        var a = document.createElement("a");
        a.href = 'https://dls-controls.github.io/scanspec/' + name;
        a.innerText = name;
        li.appendChild(a)
        document.getElementById('versions').appendChild(li);
      }
    }
    Promise.all([
      // Find gh-pages directories and populate `dirs`
      fetch("https://api.github.com/repos/dls-controls/scanspec/contents?ref=gh-pages")
      .then(response => response.json())
      .then(data => data.forEach(function(e) {
        if (e.type == "dir") dirs.add(e.name);
      })),
      // Add tags to `versions`
      fetch('https://api.github.com/repos/dls-controls/scanspec/tags')
        .then(response => response.json())
        .then(data => data.forEach(function(e) {
          versions.push(e.name);
        }))
      ]).then(_ => versions.forEach(addVersion))
  </script>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: rgb(7, 43, 93)" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">scanspec</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>scanspec.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scanspec.core</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">new_class</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">apischema</span> <span class="kn">import</span> <span class="n">deserializer</span><span class="p">,</span> <span class="n">serializer</span><span class="p">,</span> <span class="n">type_name</span>
<span class="kn">from</span> <span class="nn">apischema.conversions</span> <span class="kn">import</span> <span class="n">Conversion</span>
<span class="kn">from</span> <span class="nn">apischema.metadata</span> <span class="kn">import</span> <span class="n">conversion</span>
<span class="kn">from</span> <span class="nn">apischema.objects</span> <span class="kn">import</span> <span class="n">object_deserialization</span>
<span class="kn">from</span> <span class="nn">apischema.tagged_unions</span> <span class="kn">import</span> <span class="n">Tagged</span><span class="p">,</span> <span class="n">TaggedUnion</span><span class="p">,</span> <span class="n">get_tagged</span>
<span class="kn">from</span> <span class="nn">apischema.utils</span> <span class="kn">import</span> <span class="n">to_pascal_case</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;alternative_constructor&quot;</span><span class="p">,</span>
    <span class="s2">&quot;as_tagged_union&quot;</span><span class="p">,</span>
    <span class="s2">&quot;if_instance_do&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Axis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AxesPoints&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Frames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SnakedFrames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gap_between_frames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;squash_frames&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Path&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Midpoints&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_rec_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">type</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">sub_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">sub_cls</span>
        <span class="k">yield from</span> <span class="n">_rec_subclasses</span><span class="p">(</span><span class="n">sub_cls</span><span class="p">)</span>


<span class="c1"># {cls_name: [functions]}</span>
<span class="n">_alternative_constructors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># Close enough for mypy</span>
    <span class="n">alternative_constructor</span> <span class="o">=</span> <span class="nb">staticmethod</span>
<span class="k">else</span><span class="p">:</span>

<div class="viewcode-block" id="alternative_constructor"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.alternative_constructor">[docs]</a>    <span class="k">def</span> <span class="nf">alternative_constructor</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register an alternative constructor for this class.</span>

<span class="sd">        This will be returned as a staticmethod so the signature should not</span>
<span class="sd">        include self/cls.</span>

<span class="sd">        &gt;&gt;&gt; import dataclasses</span>
<span class="sd">        &gt;&gt;&gt; @dataclasses.dataclass</span>
<span class="sd">        ... class Foo:</span>
<span class="sd">        ...     a: int</span>
<span class="sd">        ...     @alternative_constructor</span>
<span class="sd">        ...     def doubled(b: int) -&gt; &quot;Foo&quot;:</span>
<span class="sd">        ...         return Foo(b * 2)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Foo.doubled(2)</span>
<span class="sd">        Foo(a=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_name</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_alternative_constructors</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>


<span class="n">generic_name</span> <span class="o">=</span> <span class="n">type_name</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_gql_input</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert plain Python objects to their GraphQL representation.</span>

<span class="sd">    &gt;&gt;&gt; to_gql_input({&quot;a&quot;: {&quot;b&quot;: 1, &quot;c&quot;: True, &quot;d&quot;: [4.2, 3.4], &quot;e&quot;: &quot;e&quot;}})</span>
<span class="sd">    &#39;{a: {b: 1, c: true, d: [4.2, 3.4], e: &quot;e&quot;}}&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">to_gql_input</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ob</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">return</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="n">inner</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_gql_input</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ob</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">inner</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot format </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ob</span><span class="p">)</span>


<div class="viewcode-block" id="as_tagged_union"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.as_tagged_union">[docs]</a><span class="k">def</span> <span class="nf">as_tagged_union</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used by `Spec` and `Region` so they serialize as a tagged union.&quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__parameters__&quot;</span><span class="p">,</span> <span class="p">()))</span>
    <span class="n">tagged_union_bases</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">TaggedUnion</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">tagged_union_bases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TaggedUnion</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">params</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
        <span class="n">generic_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">prev_init_subclass</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__init_subclass__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prev_init_subclass</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prev_init_subclass</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">generic_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">__init_subclass__</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">with_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">[</span><span class="n">params</span><span class="p">]</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="bp">cls</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">serialization</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Conversion</span><span class="p">:</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># Assume that subclasses have same generic parameters than cls</span>
            <span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">with_params</span><span class="p">(</span><span class="n">sub</span><span class="p">)]</span>  <span class="c1"># type: ignore</span>
            <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">_rec_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;__annotations__&quot;</span><span class="p">:</span> <span class="n">annotations</span><span class="p">}</span>
        <span class="n">tagged_union</span> <span class="o">=</span> <span class="n">new_class</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">tagged_union_bases</span><span class="p">,</span> <span class="n">exec_body</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Conversion</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">tagged_union</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">obj</span><span class="p">}),</span>
            <span class="n">source</span><span class="o">=</span><span class="n">with_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">with_params</span><span class="p">(</span><span class="n">tagged_union</span><span class="p">),</span>
            <span class="c1"># Conversion must not be inherited because it would lead to</span>
            <span class="c1"># infinite recursion otherwise</span>
            <span class="n">inherited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">type_name_factory_for_subclass</span><span class="p">(</span><span class="n">sub</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_name</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">to_pascal_case</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">deserialization</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Conversion</span><span class="p">:</span>
        <span class="n">annotations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">namespace</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;__annotations__&quot;</span><span class="p">:</span> <span class="n">annotations</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">_rec_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="c1"># Assume that subclasses have same generic parameters than cls</span>
            <span class="n">annotations</span><span class="p">[</span><span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">with_params</span><span class="p">(</span><span class="n">sub</span><span class="p">)]</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># Add tagged fields for all its alternative constructors</span>
            <span class="k">for</span> <span class="n">constructor</span> <span class="ow">in</span> <span class="n">_alternative_constructors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">()):</span>
                <span class="c1"># Build the alias of the field</span>
                <span class="n">alias</span> <span class="o">=</span> <span class="n">to_pascal_case</span><span class="p">(</span><span class="n">constructor</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="n">sub</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="c1"># object_deserialization uses get_type_hints, but the constructor</span>
                <span class="c1"># return type is stringified and the class not defined yet,</span>
                <span class="c1"># so it must be assigned manually</span>
                <span class="n">constructor</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">[</span><span class="s2">&quot;return&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">with_params</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
                <span class="c1"># Use object_deserialization to wrap constructor as deserializer</span>
                <span class="n">deserialization</span> <span class="o">=</span> <span class="n">object_deserialization</span><span class="p">(</span>
                    <span class="n">constructor</span><span class="p">,</span> <span class="n">type_name_factory_for_subclass</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Add constructor tagged field with its conversion</span>
                <span class="n">annotations</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">[</span><span class="n">with_params</span><span class="p">(</span><span class="n">sub</span><span class="p">)]</span>  <span class="c1"># type: ignore</span>
                <span class="n">namespace</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tagged</span><span class="p">(</span><span class="n">conversion</span><span class="p">(</span><span class="n">deserialization</span><span class="o">=</span><span class="n">deserialization</span><span class="p">))</span>
        <span class="c1"># Create the deserialization tagged union class</span>
        <span class="n">tagged_union</span> <span class="o">=</span> <span class="n">new_class</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">tagged_union_bases</span><span class="p">,</span> <span class="n">exec_body</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ns</span><span class="p">:</span> <span class="n">ns</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Conversion</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">get_tagged</span><span class="p">(</span><span class="n">obj</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">source</span><span class="o">=</span><span class="n">with_params</span><span class="p">(</span><span class="n">tagged_union</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">with_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="n">deserializer</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="n">deserialization</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">serializer</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="n">serialization</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span></div>


<div class="viewcode-block" id="if_instance_do"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.if_instance_do">[docs]</a><span class="k">def</span> <span class="nf">if_instance_do</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If x is of type cls then return func(x), otherwise return NotImplemented.</span>

<span class="sd">    Used as a helper when implementing operator overloading.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<span class="c1">#: A type variable for an `axis_` that can be specified for a scan</span>
<span class="n">Axis</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Axis&quot;</span><span class="p">)</span>

<span class="c1">#: Map of axes to float ndarray of points</span>
<span class="c1">#: E.g. {xmotor: array([0, 1, 2]), ymotor: array([2, 2, 2])}</span>
<span class="n">AxesPoints</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Axis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>


<div class="viewcode-block" id="Frames"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Frames">[docs]</a><span class="k">class</span> <span class="nc">Frames</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Axis</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Represents a series of scan frames along a number of axes.</span>

<span class="sd">    During a scan each axis will traverse lower-midpoint-upper for each frame.</span>

<span class="sd">    Args:</span>
<span class="sd">        midpoints: The midpoints of scan frames for each axis</span>
<span class="sd">        lower: Lower bounds of scan frames if different from midpoints</span>
<span class="sd">        upper: Upper bounds of scan frames if different from midpoints</span>
<span class="sd">        gap: If supplied, define if there is a gap between frame and previous</span>
<span class="sd">            otherwise it is calculated by looking at lower and upper bounds</span>

<span class="sd">    Typically used in two ways:</span>

<span class="sd">    - A list of Frames objects returned from `Spec.calculate` represents a scan</span>
<span class="sd">      as a linear stack of frames. Interpreted as nested from slowest moving to</span>
<span class="sd">      fastest moving, so each faster Frames object will iterate once per</span>
<span class="sd">      position of the slower Frames object. It is passed to a `Path` for</span>
<span class="sd">      calculation of the actual scan path.</span>
<span class="sd">    - A single Frames object returned from `Path.consume` represents a chunk of</span>
<span class="sd">      frames forming part of a scan path, for interpretation by the code</span>
<span class="sd">      that will actually perform the scan.</span>

<span class="sd">    See Also:</span>
<span class="sd">        `technical-terms`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">midpoints</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">],</span>
        <span class="n">lower</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">gap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1">#: The midpoints of scan frames for each axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="o">=</span> <span class="n">midpoints</span>
        <span class="c1">#: The lower bounds of each scan frame in each axis for fly-scanning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span> <span class="ow">or</span> <span class="n">midpoints</span>
        <span class="c1">#: The upper bounds of each scan frame in each axis for fly-scanning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span> <span class="ow">or</span> <span class="n">midpoints</span>
        <span class="k">if</span> <span class="n">gap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#: Whether there is a gap between this frame and the previous. First</span>
            <span class="c1">#: element is whether there is a gap between the last frame and the first</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gap</span> <span class="o">=</span> <span class="n">gap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Need to calculate gap as not passed one</span>
            <span class="c1"># We have a gap if upper[i] != lower[i+1] for any axes</span>
            <span class="n">axes_gap</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">l</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">axes_gap</span><span class="p">)</span>
        <span class="c1"># Check all axes and ordering are the same</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Mismatching axes &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Check all lengths are the same</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">lengths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Mismatching lengths </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="Frames.axes"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Frames.axes">[docs]</a>    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The axes which will move during the scan.</span>

<span class="sd">        These will be present in `midpoints`, `lower` and `upper`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of frames in this section of the scan.&quot;&quot;&quot;</span>
        <span class="c1"># All axespoints arrays are same length, pick the first one</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">)</span>

<div class="viewcode-block" id="Frames.extract"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Frames.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">calculate_gap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Frames[Axis]&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Frames object restricted to the indices provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices: The indices of the frames to extract, modulo scan length</span>
<span class="sd">            calculate_gap: If True then recalculate the gap from upper and lower</span>

<span class="sd">        &gt;&gt;&gt; frames = Frames({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; frames.extract(np.array([1, 0, 1])).midpoints</span>
<span class="sd">        {&#39;x&#39;: array([2, 1, 2])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_indices</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">extract_dict</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">dim_indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">extract_gap</span><span class="p">(</span><span class="n">gaps</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="n">gaps</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">calculate_gap</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">gap</span><span class="p">[</span><span class="n">dim_indices</span><span class="p">]</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">_merge_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_merge</span><span class="o">=</span><span class="n">extract_dict</span><span class="p">,</span> <span class="n">gap_merge</span><span class="o">=</span><span class="n">extract_gap</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frames.concat"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Frames.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Frames[Axis]&quot;</span><span class="p">,</span> <span class="n">gap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Frames[Axis]&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Frames object concatenating self and other.</span>

<span class="sd">        Requires both Frames objects to have the same axes.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The Frames to concatenate to self</span>
<span class="sd">            gap: Whether to force a gap between the two Frames objects</span>

<span class="sd">        &gt;&gt;&gt; frames = Frames({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; frames2 = Frames({&quot;x&quot;: np.array([5, 6, 7])})</span>
<span class="sd">        &gt;&gt;&gt; frames.concat(frames2).midpoints</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3, 5, 6, 7])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;axes </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">def</span> <span class="nf">concat_dict</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
            <span class="c1"># Concat each array in midpoints, lower, upper. E.g.</span>
            <span class="c1"># lower[ax] = np.concatenate(self.lower[ax], other.lower[ax])</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">()}</span>

        <span class="k">def</span> <span class="nf">concat_gap</span><span class="p">(</span><span class="n">gaps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>
            <span class="c1"># Calc the first frame</span>
            <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_between_frames</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="c1"># And the join frame</span>
            <span class="n">g</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">gap</span> <span class="ow">or</span> <span class="n">gap_between_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">g</span>

        <span class="k">return</span> <span class="n">_merge_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">dict_merge</span><span class="o">=</span><span class="n">concat_dict</span><span class="p">,</span> <span class="n">gap_merge</span><span class="o">=</span><span class="n">concat_gap</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frames.zip"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Frames.zip">[docs]</a>    <span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Frames[Axis]&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Frames[Axis]&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Frames object merging self and other.</span>

<span class="sd">        Require both Frames objects to not share axes.</span>

<span class="sd">        &gt;&gt;&gt; fx = Frames({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; fy = Frames({&quot;y&quot;: np.array([5, 6, 7])})</span>
<span class="sd">        &gt;&gt;&gt; fx.zip(fy).midpoints</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3]), &#39;y&#39;: array([5, 6, 7])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlapping</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">()))</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">overlapping</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Zipping would overwrite axes </span><span class="si">{</span><span class="n">overlapping</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">def</span> <span class="nf">zip_dict</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
            <span class="c1"># Merge dicts for midpoints, lower, upper. E.g.</span>
            <span class="c1"># lower[ax] = {**self.lower[ax], **other.lower[ax]}</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kv</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span> <span class="k">for</span> <span class="n">kv</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">zip_gap</span><span class="p">(</span><span class="n">gaps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="c1"># Gap if either frames has a gap. E.g.</span>
            <span class="c1"># gap[i] = self.gap[i] | other.gap[i]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_merge_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">dict_merge</span><span class="o">=</span><span class="n">zip_dict</span><span class="p">,</span> <span class="n">gap_merge</span><span class="o">=</span><span class="n">zip_gap</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_merge_frames</span><span class="p">(</span>
    <span class="o">*</span><span class="n">stack</span><span class="p">:</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">],</span>
    <span class="n">dict_merge</span><span class="o">=</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]]],</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]],</span>
    <span class="n">gap_merge</span><span class="o">=</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
    <span class="n">types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Mismatching types for </span><span class="si">{</span><span class="n">stack</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="c1"># If any lower or upper are different, apply to those</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">midpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_merge</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">])</span>

    <span class="c1"># Apply to midpoints, force calculation of gap</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">midpoints</span><span class="o">=</span><span class="n">dict_merge</span><span class="p">([</span><span class="n">fs</span><span class="o">.</span><span class="n">midpoints</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">]),</span>
        <span class="n">gap</span><span class="o">=</span><span class="n">gap_merge</span><span class="p">([</span><span class="n">fs</span><span class="o">.</span><span class="n">gap</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">]),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="SnakedFrames"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.SnakedFrames">[docs]</a><span class="k">class</span> <span class="nc">SnakedFrames</span><span class="p">(</span><span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Like a `Frames` object, but each alternate repetition will run in reverse.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">midpoints</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">],</span>
        <span class="n">lower</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper</span><span class="p">:</span> <span class="n">AxesPoints</span><span class="p">[</span><span class="n">Axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">gap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">midpoints</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">upper</span><span class="p">,</span> <span class="n">gap</span><span class="o">=</span><span class="n">gap</span><span class="p">)</span>
        <span class="c1"># Override first element of gap to be True, as subsequent runs</span>
        <span class="c1"># of snake scans are always joined end -&gt; start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="SnakedFrames.from_frames"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.SnakedFrames.from_frames">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_frames</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">frames</span><span class="p">:</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;SnakedFrames[Axis]&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a snaked version of a `Frames` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">midpoints</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">gap</span><span class="p">)</span></div>

<div class="viewcode-block" id="SnakedFrames.extract"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.SnakedFrames.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">calculate_gap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a new Frames object restricted to the indices provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices: The indices of the frames to extract, can extend past len(self)</span>
<span class="sd">            calculate_gap: If True then recalculate the gap from upper and lower</span>

<span class="sd">        &gt;&gt;&gt; frames = SnakedFrames({&quot;x&quot;: np.array([1, 2, 3])})</span>
<span class="sd">        &gt;&gt;&gt; frames.extract(np.array([0, 1, 2, 3, 4, 5])).midpoints</span>
<span class="sd">        {&#39;x&#39;: array([1, 2, 3, 3, 2, 1])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the indices</span>
        <span class="c1"># E.g for len = 4</span>
        <span class="c1"># indices:       0123456789</span>
        <span class="c1"># backwards:     0000111100</span>
        <span class="c1"># snake_indices: 0123321001</span>
        <span class="c1"># gap_indices:   0123032101</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">backwards</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">//</span> <span class="n">length</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">snake_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">backwards</span><span class="p">,</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">%</span> <span class="n">length</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">calculate_gap</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">Frames</span>
            <span class="n">gap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">backwards</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">%</span> <span class="n">length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">gap</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If lower or upper are different, apply to those</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">:</span>
            <span class="c1"># If going backwards select from the opposite bound</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">backwards</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">snake_indices</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;upper&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">backwards</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">snake_indices</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">snake_indices</span><span class="p">],)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="c1"># Apply to midpoints</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">snake_indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span> <span class="n">gap</span><span class="o">=</span><span class="n">gap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="gap_between_frames"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.gap_between_frames">[docs]</a><span class="k">def</span> <span class="nf">gap_between_frames</span><span class="p">(</span><span class="n">frames1</span><span class="p">:</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">],</span> <span class="n">frames2</span><span class="p">:</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Is there a gap between end of frames1 and start of frames2.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">frames1</span><span class="o">.</span><span class="n">upper</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">frames2</span><span class="o">.</span><span class="n">lower</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frames1</span><span class="o">.</span><span class="n">axes</span><span class="p">())</span></div>


<div class="viewcode-block" id="squash_frames"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.squash_frames">[docs]</a><span class="k">def</span> <span class="nf">squash_frames</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]],</span> <span class="n">check_path_changes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Squash a stack of nested Frames into a single one.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack: The Frames stack to squash, from slowest to fastest moving</span>
<span class="sd">        check_path_changes: If True then check that nesting the output</span>
<span class="sd">            Frames object within others will provide the same path</span>
<span class="sd">            as nesting the input Frames stack within others</span>

<span class="sd">    See Also:</span>
<span class="sd">        `why-squash-can-change-path`</span>

<span class="sd">    &gt;&gt;&gt; fx = SnakedFrames({&quot;x&quot;: np.array([1, 2])})</span>
<span class="sd">    &gt;&gt;&gt; fy = Frames({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">    &gt;&gt;&gt; squash_frames([fy, fx]).midpoints</span>
<span class="sd">    {&#39;y&#39;: array([3, 3, 4, 4]), &#39;x&#39;: array([1, 2, 2, 1])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
    <span class="c1"># Consuming a Path through these Frames performs the squash</span>
    <span class="n">squashed</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">consume</span><span class="p">()</span>
    <span class="c1"># Check that the squash is the same as the original</span>
    <span class="k">if</span> <span class="n">stack</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SnakedFrames</span><span class="p">):</span>
        <span class="n">squashed</span> <span class="o">=</span> <span class="n">SnakedFrames</span><span class="o">.</span><span class="n">from_frames</span><span class="p">(</span><span class="n">squashed</span><span class="p">)</span>
        <span class="c1"># The top level is snaking, so this Frames object will run backwards</span>
        <span class="c1"># This means any non-snaking axes will run backwards, which is</span>
        <span class="c1"># surprising, so don&#39;t allow it</span>
        <span class="k">if</span> <span class="n">check_path_changes</span><span class="p">:</span>
            <span class="n">non_snaking</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">k</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">stack</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">SnakedFrames</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">non_snaking</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot squash non-snaking Frames inside a SnakingFrames &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;otherwise </span><span class="si">{</span><span class="n">non_snaking</span><span class="si">}</span><span class="s2"> would run backwards&quot;</span>
                <span class="p">)</span>
    <span class="k">elif</span> <span class="n">check_path_changes</span><span class="p">:</span>
        <span class="c1"># The top level is not snaking, so make sure there is an even</span>
        <span class="c1"># number of iterations of any snaking axis within it so it</span>
        <span class="c1"># doesn&#39;t jump when this frames object is iterated a second time</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frames</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
            <span class="c1"># A SnakedFrames within a non-snaking top level must repeat</span>
            <span class="c1"># an even number of times</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">SnakedFrames</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">lengths</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot squash SnakingFrames inside a non-snaking Frames &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;when they do not repeat an even number of times &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;otherwise </span><span class="si">{</span><span class="n">frames</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="si">}</span><span class="s2"> would jump in position&quot;</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">squashed</span></div>


<div class="viewcode-block" id="Path"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Path">[docs]</a><span class="k">class</span> <span class="nc">Path</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Axis</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;A consumable route through a stack of Frames, representing a scan path.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack: The Frames stack describing the scan, from slowest to fastest</span>
<span class="sd">            moving</span>
<span class="sd">        start: The index of where in the Path to start</span>
<span class="sd">        num: The number of scan frames to produce after start. None means up to</span>
<span class="sd">            the end</span>

<span class="sd">    See Also:</span>
<span class="sd">        `iterate-a-spec`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1">#: The Frames stack describing the scan, from slowest to fastest moving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span>
        <span class="c1">#: Index that is next to be consumed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">start</span>
        <span class="c1">#: The lengths of all the stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">])</span>
        <span class="c1">#: Index of the end frame, one more than the last index that will be</span>
        <span class="c1">#: produced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num</span>

<div class="viewcode-block" id="Path.consume"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Path.consume">[docs]</a>    <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Consume at most num frames from the Path and return as a Frames object.</span>

<span class="sd">        &gt;&gt;&gt; fx = SnakedFrames({&quot;x&quot;: np.array([1, 2])})</span>
<span class="sd">        &gt;&gt;&gt; fy = Frames({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">        &gt;&gt;&gt; path = Path([fy, fx])</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).midpoints</span>
<span class="sd">        {&#39;y&#39;: array([3, 3, 4]), &#39;x&#39;: array([1, 2, 2])}</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).midpoints</span>
<span class="sd">        {&#39;y&#39;: array([4]), &#39;x&#39;: array([1])}</span>
<span class="sd">        &gt;&gt;&gt; path.consume(3).midpoints</span>
<span class="sd">        {&#39;y&#39;: array([], dtype=int64), &#39;x&#39;: array([], dtype=int64)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">end_index</span>
        <span class="n">stack</span><span class="p">:</span> <span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">Frames</span><span class="p">(</span>
            <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Example numbers below from a 2x3x4 ZxYxX scan</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frames</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">):</span>
            <span class="c1"># Number of times each frame will repeat: Z:12, Y:4, X:1</span>
            <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="c1"># Scan indices mapped to indices within Frames object:</span>
            <span class="c1"># Z:000000000000111111111111</span>
            <span class="c1"># Y:000011112222000011112222</span>
            <span class="c1"># X:012301230123012301230123</span>
            <span class="k">if</span> <span class="n">repeats</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dim_indices</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">//</span> <span class="n">repeats</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim_indices</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="c1"># Create the sliced frames</span>
            <span class="n">sliced</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">dim_indices</span><span class="p">,</span> <span class="n">calculate_gap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">repeats</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Whether this frames contributes to the gap bit</span>
                <span class="c1"># Z:000000000000100000000000</span>
                <span class="c1"># Y:000010001000100010001000</span>
                <span class="c1"># X:111111111111111111111111</span>
                <span class="n">in_gap</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">%</span> <span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="c1"># If in_gap, then keep the relevant gap bit</span>
                <span class="n">sliced</span><span class="o">.</span><span class="n">gap</span> <span class="o">&amp;=</span> <span class="n">in_gap</span>
            <span class="c1"># Zip it with the output Frames object</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">sliced</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stack</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of frames left in a scan, reduces when `consume` is called.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span></div>


<div class="viewcode-block" id="Midpoints"><a class="viewcode-back" href="../../reference/api.html#scanspec.core.Midpoints">[docs]</a><span class="k">class</span> <span class="nc">Midpoints</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Axis</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Convenience iterable that produces the scan midpoints for each axis.</span>

<span class="sd">    For better performance, consume from a `Path` instead.</span>

<span class="sd">    Args:</span>
<span class="sd">        stack: The stack of Frames describing the scan, from slowest to fastest</span>
<span class="sd">            moving</span>

<span class="sd">    See Also:</span>
<span class="sd">        `iterate-a-spec`</span>

<span class="sd">    &gt;&gt;&gt; fx = SnakedFrames({&quot;x&quot;: np.array([1, 2])})</span>
<span class="sd">    &gt;&gt;&gt; fy = Frames({&quot;y&quot;: np.array([3, 4])})</span>
<span class="sd">    &gt;&gt;&gt; mp = Midpoints([fy, fx])</span>
<span class="sd">    &gt;&gt;&gt; for p in mp: print(p)</span>
<span class="sd">    {&#39;y&#39;: 3, &#39;x&#39;: 1}</span>
<span class="sd">    {&#39;y&#39;: 3, &#39;x&#39;: 2}</span>
<span class="sd">    {&#39;y&#39;: 4, &#39;x&#39;: 2}</span>
<span class="sd">    {&#39;y&#39;: 4, &#39;x&#39;: 1}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Frames</span><span class="p">[</span><span class="n">Axis</span><span class="p">]]):</span>
        <span class="c1">#: The stack of Frames describing the scan, from slowest to fastest moving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The axes that will be present in each points dictionary.&quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">frames</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">+=</span> <span class="n">frames</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of dictionaries that will be produced if iterated over.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="k">for</span> <span class="n">frames</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Axis</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Yield {axis: midpoint} for each frame in the scan.&quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">frames</span><span class="o">.</span><span class="n">midpoints</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frames</span><span class="o">.</span><span class="n">axes</span><span class="p">()}</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Diamond Light Source.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>